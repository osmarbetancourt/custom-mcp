# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-07-12T20:02:31+00:00

from __future__ import annotations

from typing import List
import os
import httpx
import logging
from fastapi import FastAPI, Path, HTTPException

from .models import (
    RenderCreateDBRequest,
    RenderCreateDBResponse,
    RenderCreateServiceRequest,
    RenderCustomDomain,
    RenderDatabase,
    RenderDatabaseConnection,
    RenderDatabaseUser,
    RenderDeploy,
    RenderEnvVar,
    RenderService,
)

app = FastAPI(
    title='MCP API',
    version='1.0.0',
)

# --- MCP Endpoints ---
from fastapi import Body
from fastapi.responses import JSONResponse

@app.get('/v1/health')
async def mcp_health():
    """
    MCP health check endpoint
    """
    return {"status": "ok"}

@app.post('/v1/context')
async def mcp_context(request: dict = Body(...)):
    """
    MCP context endpoint (stub)
    """
    # TODO: Implement context retrieval logic
    # For now, return a stub response
    return JSONResponse({
        "context": [],
        "request": request
    })

@app.post('/v1/search')
async def mcp_search(request: dict = Body(...)):
    """
    MCP search endpoint (stub)
    """
    # TODO: Implement search logic
    # For now, return a stub response
    return JSONResponse({
        "results": [],
        "request": request
    })

RENDER_API_URL = "https://api.render.com/v1"
RENDER_API_KEY = os.getenv("RENDER_API_KEY")

def get_headers():
    if not RENDER_API_KEY:
        raise HTTPException(status_code=500, detail="RENDER_API_KEY not set in environment")
    return {"Authorization": f"Bearer {RENDER_API_KEY}", "Accept": "application/json"}

@app.post('/render/create-db')
async def post_render_create_db(body: RenderCreateDBRequest):
    """
    Create a new PostgreSQL database on Render
    """
    url = f"{RENDER_API_URL}/postgres"
    async with httpx.AsyncClient() as client:
        resp = await client.post(url, headers=get_headers(), json=body.dict())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.get('/render/databases')
async def get_render_databases():
    """
    List all database services
    """
    url = f"{RENDER_API_URL}/postgres"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()


@app.get('/render/databases/{databaseId}')
async def get_render_databases_database_id(
    database_id: str = Path(..., alias='databaseId')
):
    """
    Get a specific database service
    """
    url = f"{RENDER_API_URL}/postgres/{database_id}"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

# Add DELETE endpoint for database deletion
@app.delete('/render/databases/{databaseId}')
async def delete_render_database(database_id: str = Path(..., alias='databaseId')):
    """
    Delete a specific database service
    """
    url = f"{RENDER_API_URL}/postgres/{database_id}"
    async with httpx.AsyncClient() as client:
        resp = await client.delete(url, headers=get_headers())
    if resp.status_code != 204:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return {"detail": "Database deleted"}

@app.get('/render/databases/{databaseId}/connection')
async def get_render_databases_database_id_connection(
    database_id: str = Path(..., alias='databaseId')
):
    """
    Get connection info for a database
    """
    url = f"{RENDER_API_URL}/postgres/{database_id}/connection"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.get('/render/databases/{databaseId}/users')
async def get_render_databases_database_id_users(
    database_id: str = Path(..., alias='databaseId')
):
    """
    List users for a database
    """
    url = f"{RENDER_API_URL}/postgres/{database_id}/users"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.get('/render/deploys/{deployId}')
async def get_render_deploys_deploy_id(
    deploy_id: str = Path(..., alias='deployId')
):
    """
    Get a specific deploy
    """
    url = f"{RENDER_API_URL}/deploys/{deploy_id}"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.post('/render/services')
async def post_render_services(body: RenderCreateServiceRequest):
    """
    Create a new Render service
    """
    url = f"{RENDER_API_URL}/services"
    async with httpx.AsyncClient() as client:
        resp = await client.post(url, headers=get_headers(), json=body.dict())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.get('/render/services')
async def get_render_services():
    """
    List Render services
    """
    url = f"{RENDER_API_URL}/services"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.get('/render/services/{serviceId}')
async def get_render_services_service_id(
    service_id: str = Path(..., alias='serviceId')
):
    """
    Get a specific Render service
    """
    url = f"{RENDER_API_URL}/services/{service_id}"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.get('/render/services/{serviceId}/custom-domains')
async def get_render_services_service_id_custom_domains(
    service_id: str = Path(..., alias='serviceId')
):
    """
    List custom domains for a service
    """
    url = f"{RENDER_API_URL}/services/{service_id}/custom-domains"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.get('/render/services/{serviceId}/deploys')
async def get_render_services_service_id_deploys(
    service_id: str = Path(..., alias='serviceId')
):
    """
    List deploys for a service
    """
    url = f"{RENDER_API_URL}/services/{service_id}/deploys"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.get('/render/services/{serviceId}/env-vars')
async def get_render_services_service_id_env_vars(
    service_id: str = Path(..., alias='serviceId')
):
    """
    List environment variables for a service
    """
    url = f"{RENDER_API_URL}/services/{service_id}/env-vars"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()
