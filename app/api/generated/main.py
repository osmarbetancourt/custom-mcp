# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-07-12T20:02:31+00:00

from __future__ import annotations

from typing import List

import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../..')))
import httpx
import logging

from fastapi import FastAPI, Path, HTTPException, Query
from render_public_api_client.client import AuthenticatedClient
from render_public_api_client.api.deploys import list_deploys
from render_public_api_client.types import UNSET

from .models import (
    RenderCreateDBRequest,
    RenderCreateDBResponse,
    RenderCreateServiceRequest,
    RenderCustomDomain,
    RenderDatabase,
    RenderDatabaseConnection,
    RenderDatabaseUser,
    RenderDeploy,
    RenderEnvVar,
    RenderService,
)

app = FastAPI(
    title='MCP API',
    version='1.0.0',
)



try:
    from render_auto_routes import router as auto_router
    app.include_router(auto_router, prefix="")

    @app.get("/auto-routes",tags=["render","automatic"])
    async def list_auto_routes():
        routes = []
        for route in auto_router.routes:
            if hasattr(route, 'methods') and hasattr(route, 'path'):
                for method in route.methods:
                    if method not in ("HEAD", "OPTIONS"):
                        routes.append({"method": method, "path": f"{route.path}"})
        return sorted(routes, key=lambda r: (r["path"], r["method"]))

    # Log unmapped endpoints to a file
    def log_unmapped_endpoints():
        mapped_paths = set()
        for route in auto_router.routes:
            if hasattr(route, 'path'):
                mapped_paths.add(route.path)
        # Load all expected routes from render_api_routes.py
        try:
            from render_api_routes import render_api_routes
        except Exception as e:
            print(f"[ERROR] Could not import render_api_routes: {e}", file=sys.stderr)
            return
        unmapped = []
        for entry in render_api_routes:
            route_path = entry["route"]
            # FastAPI auto_router uses /demo prefix
            demo_path = f"{route_path}"
            if demo_path not in mapped_paths:
                unmapped.append({"route": route_path, "methods": entry["methods"], "operationId": entry["operationId"]})
        if unmapped:
            with open("unmapped_endpoints.log", "w", encoding="utf-8") as f:
                for entry in unmapped:
                    f.write(f"{entry}\n")
            print(f"[INFO] Wrote {len(unmapped)} unmapped endpoints to unmapped_endpoints.log", file=sys.stderr)
        else:
            print("[INFO] All endpoints mapped.", file=sys.stderr)

    log_unmapped_endpoints()

    @app.get("/unmapped-endpoints", tags=["demo"])
    async def get_unmapped_endpoints():
        """
        Return the contents of unmapped_endpoints.log (endpoints that could not be mapped by the auto-router).
        """
        try:
            with open("unmapped_endpoints.log", "r", encoding="utf-8") as f:
                lines = f.readlines()
            return {"unmapped_endpoints": [line.strip() for line in lines]}
        except FileNotFoundError:
            return {"unmapped_endpoints": [], "detail": "No unmapped_endpoints.log file found."}
except Exception as e:
    print(f"[WARN] Could not mount auto-generated router: {e}", file=sys.stderr)

@app.get('/render/services/{serviceId}/deploys-generated',tags=["render"])
async def get_render_services_service_id_deploys_generated(
    service_id: str = Path(..., alias='serviceId'),
    limit: int = Query(20, description="Max number of deploys to return")
):
    """
    List deploys for a service using the generated Render API client
    """
    api_key = os.getenv("RENDER_API_KEY")
    if not api_key:
        raise HTTPException(status_code=500, detail="RENDER_API_KEY not set in environment")
    client = AuthenticatedClient(
        base_url="https://api.render.com/v1",
        token=api_key
    )
    result = list_deploys.sync(service_id=service_id, client=client, limit=limit)
    if isinstance(result, list):
        return [d.to_dict() for d in result]
    else:
        # result is an Error object
        raise HTTPException(status_code=400, detail=str(result))

# --- MCP Endpoints ---
from fastapi import Body
from fastapi.responses import JSONResponse

@app.get('/v1/health',tags=["copilot-mcp"])
async def mcp_health():
    """
    MCP health check endpoint
    """
    return {"status": "ok"}

@app.post('/v1/context')
async def mcp_context(request: dict = Body(...)):
    """
    MCP context endpoint (stub)
    """
    # TODO: Implement context retrieval logic
    # For now, return a stub response
    return JSONResponse({
        "context": [],
        "request": request
    })

@app.post('/v1/search')
async def mcp_search(request: dict = Body(...)):
    """
    MCP search endpoint (stub)
    """
    # TODO: Implement search logic
    # For now, return a stub response
    return JSONResponse({
        "results": [],
        "request": request
    })

RENDER_API_URL = "https://api.render.com/v1"
RENDER_API_KEY = os.getenv("RENDER_API_KEY")

def get_headers():
    if not RENDER_API_KEY:
        raise HTTPException(status_code=500, detail="RENDER_API_KEY not set in environment")
    return {"Authorization": f"Bearer {RENDER_API_KEY}", "Accept": "application/json"}

@app.post('/render/create-db')
async def post_render_create_db(body: RenderCreateDBRequest):
    """
    Create a new PostgreSQL database on Render
    """
    url = f"{RENDER_API_URL}/postgres"
    async with httpx.AsyncClient() as client:
        resp = await client.post(url, headers=get_headers(), json=body.dict())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.get('/render/databases')
async def get_render_databases():
    """
    List all database services
    """
    url = f"{RENDER_API_URL}/postgres"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    data = resp.json()
    # Always return a list, even if API returns None or unexpected value
    if not isinstance(data, list):
        return []
    return data


@app.get('/render/databases/{databaseId}')
async def get_render_databases_database_id(
    database_id: str = Path(..., alias='databaseId')
):
    """
    Get a specific database service
    """
    url = f"{RENDER_API_URL}/postgres/{database_id}"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

# Add DELETE endpoint for database deletion
@app.delete('/render/databases/{databaseId}')
async def delete_render_database(database_id: str = Path(..., alias='databaseId')):
    """
    Delete a specific database service
    """
    url = f"{RENDER_API_URL}/postgres/{database_id}"
    async with httpx.AsyncClient() as client:
        resp = await client.delete(url, headers=get_headers())
    if resp.status_code != 204:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return {"detail": "Database deleted"}

@app.get('/render/databases/{databaseId}/connection')
async def get_render_databases_database_id_connection(
    database_id: str = Path(..., alias='databaseId')
):
    """
    Get connection info for a database
    """
    url = f"{RENDER_API_URL}/postgres/{database_id}/connection"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.get('/render/databases/{databaseId}/users')
async def get_render_databases_database_id_users(
    database_id: str = Path(..., alias='databaseId')
):
    """
    List users for a database
    """
    url = f"{RENDER_API_URL}/postgres/{database_id}/users"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.get('/render/deploys/{deployId}')
async def get_render_deploys_deploy_id(
    deploy_id: str = Path(..., alias='deployId')
):
    """
    Get a specific deploy
    """
    url = f"{RENDER_API_URL}/deploys/{deploy_id}"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.post('/render/services')
async def post_render_services(body: RenderCreateServiceRequest):
    """
    Create a new Render service
    """
    url = f"{RENDER_API_URL}/services"
    async with httpx.AsyncClient() as client:
        resp = await client.post(url, headers=get_headers(), json=body.dict())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.get('/render/services')
async def get_render_services():
    """
    List Render services
    """
    url = f"{RENDER_API_URL}/services"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.get('/render/services/{serviceId}')
async def get_render_services_service_id(
    service_id: str = Path(..., alias='serviceId')
):
    """
    Get a specific Render service
    """
    url = f"{RENDER_API_URL}/services/{service_id}"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.get('/render/services/{serviceId}/custom-domains')
async def get_render_services_service_id_custom_domains(
    service_id: str = Path(..., alias='serviceId')
):
    """
    List custom domains for a service
    """
    url = f"{RENDER_API_URL}/services/{service_id}/custom-domains"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.get('/render/services/{serviceId}/deploys')
async def get_render_services_service_id_deploys(
    service_id: str = Path(..., alias='serviceId')
):
    """
    List deploys for a service
    """
    url = f"{RENDER_API_URL}/services/{service_id}/deploys"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()

@app.get('/render/services/{serviceId}/env-vars')
async def get_render_services_service_id_env_vars(
    service_id: str = Path(..., alias='serviceId')
):
    """
    List environment variables for a service
    """
    url = f"{RENDER_API_URL}/services/{service_id}/env-vars"
    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=get_headers())
    if resp.status_code != 200:
        raise HTTPException(status_code=resp.status_code, detail=resp.text)
    return resp.json()
